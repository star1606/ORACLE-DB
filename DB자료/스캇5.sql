

--RANK OVER
SELECT ENAME, SAL, RANK() OVER (ORDER BY SAL DESC)
FROM EMP;



SELECT NAME, HEIGHT, GRADE, RANK() OVER (ORDER BY HEIGHT DESC) "키순위"
FROM STUDENT;

--1인그룹 2인그룹 3인그룹 4인그룹 분할하기
SELECT NAME, GRADE, HEIGHT, RANK() OVER(ORDER BY HEIGHT)
FROM STUDENT
WHERE GRADE = 1
UNION ALL
SELECT NAME, GRADE, HEIGHT, RANK() OVER(ORDER BY HEIGHT)
FROM STUDENT
WHERE GRADE = 2
UNION ALL
SELECT NAME, GRADE, HEIGHT, RANK() OVER(ORDER BY HEIGHT)
FROM STUDENT
WHERE GRADE = 3

UNION ALL

SELECT NAME, GRADE, HEIGHT, RANK() OVER(ORDER BY HEIGHT)
FROM STUDENT
WHERE GRADE = 4;



SELECT NAME, GRADE, HEIGHT,
RANK() OVER (PARTITION BY GRADE ORDER BY HEIGHT DESC)
FROM STUDENT;
 
 
 
SELECT DEPTNO, SAL, EMPNO, JOB, SAL,
--RANK() OVER(ORDER BY  SAL DESC)
--DENSE_RANK() OVER(ORDER BY  SAL DESC)
ROW_NUMBER() OVER (ORDER BY  SAL DESC)
FROM EMP;







--- JOIN ---
--4
SELECT *
FROM DEPT;

--14
SELECT *
FROM EMP;


--4*14=56 카티션곱
SELECT *
FROM EMP, DEPT
ORDER BY ENAME;

SELECT *
FROM EMP
WHERE DEPTNO = 10;


--조인 왼쪽테이블 오른쪽테이블 붙이는것


--INNER 조인
SELECT E.ENAME, E.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;

select *
from emp;

SELECT *
FROM DEPT;

--10번에 있는 직원이 누구인지 궁금하다

SELECT *
FROM DEPT D, EMP E
WHERE D.DEPTNO = E.DEPTNO;

DELETE FROM DEPT WHERE DEPTNO = 10;
SELECT *
FROM DEPT D, EMP E
WHERE D.DEPTNO = E.DEPTNO;
DELETE FROM DEPT WHERE DEPTNO = 20;

SELECT *
FROM DEPT D, EMP E
WHERE D.DEPTNO = E.DEPTNO;
ROLLBACK;

SELECT *
FROM DEPT D, EMP E
WHERE D.DEPTNO = E.DEPTNO;


SELECT *
FROM DEPT;

SELECT *
FROM EMP
ORDER BY DEPTNO ASC;



SELECT *
FROM DEPT D, EMP E
WHERE D.DEPTNO = E.DEPTNO;

SELECT *
FROM EMP E, DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO;

SELECT *
FROM EMP E, DEPT D
WHERE D.DEPTNO = E.DEPTNO(+) ;
--+붙은쪽에 NULL값나옴 오른쪽은 다 뽑아라 오른쪽기준 RIGHT OUTER 조인
--동일 하지 않은것도  출력, 오른쪽에 있는거 모두 출력하라
--데이터 베이스는 OBJECT를 저장할 수 없다.
--테이블의 한 행(레코드) -오브젝트
--JOIN 똑같은거 찾으며 바로 매칭
--조인을 하는데 다 보고 싶으면 OUTER 조인을 써서 자기를 팔로우 안한사람도 볼 수 있다 

--230PAGE 사용예 2 PROFNO
SELECT STUDENT.NAME STU_NAME, PROFESSOR.NAME PROF_NAME
FROM STUDENT, PROFESSOR
WHERE STUDENT.PROFNO = PROFESSOR.PROFNO;




--DDL 테이블 삭제(DROP), 수정(ALTER), 생성(CREATE)할때 사용 DATA DEFITINITIONAL LANGUAGE
CREATE TABLE REPLY(
    id number,
    content varchar2(200) NOT NULL,
    boardId number,
    userId number,
    CONSTRAINT REPLY_PK PRIMARY KEY (id),
    CONSTRAINT REPLY_FK_BOARD_ID FOREIGN KEY (boardId)REFERENCES Board (id),
    CONSTRAINT REPLY_FK_USER_ID FOREIGN KEY (userId) REFERENCES Users (id)
);

CREATE SEQUENCE users_seq
INCREMENT BY 1
START WITH 1;

CREATE SEQUENCE board_seq
INCREMENT BY 1
START WITH 1;

CREATE SEQUENCE reply_seq
INCREMENT BY 1
START WITH 1;

--USERS, BOARD, REPLY 순서대로
--DML 데이터 조작어

INSERT INTO USERS  --다넣을거면 생략가능(ID, USERNAME, EMAIL) 
VALUES(USERS_SEQ.nextval, 'ssar', 'ssar@nate.com');

INSERT INTO USERS (ID, USERNAME, EMAIL) 
VALUES(USERS_SEQ.nextval, 'love', 'love@nate.com');

INSERT INTO USERS(ID, USERNAME, EMAIL) 
VALUES(USERS_SEQ.nextval, 'cos', 'cos@nate.com');

commit;
SELECT * FROM USERS;


INSERT INTO BOARD(ID, TITLE, CONTENT, USERID)
VALUES(BOARD_SEQ.nextval, '오라클 1강', 'DDL이란?', 1);

INSERT INTO BOARD(ID, TITLE, CONTENT, USERID)
VALUES(BOARD_SEQ.nextval, '오라클 2강', 'DML이란?', 1);

INSERT INTO BOARD(ID, TITLE, CONTENT, USERID)
VALUES(BOARD_SEQ.nextval, '오라클 3강', 'DCL이란?', 2);

INSERT INTO BOARD(ID, TITLE, CONTENT, USERID)
VALUES(BOARD_SEQ.nextval, '오라클 4강', 'DQL이란?', 1);

COMMIT;

INSERT INTO REPLY(ID, CONTENT, BOARDID, USERID)
VALUES(REPLY_SEQ.nextval, '재밌어요', 1, 1);

INSERT INTO REPLY(ID, CONTENT, BOARDID, USERID)
VALUES(REPLY_SEQ.nextval, '진짜 재밌어요', 1, 2);

INSERT INTO REPLY(ID, CONTENT, BOARDID, USERID)
VALUES(REPLY_SEQ.nextval, '재밌어요', 1, 2);

COMMIT;

SELECT *
FROM REPLY;
SELECT *
FROM BOARD;


--조인
SELECT *
FROM USERS U, BOARD B
WHERE U.ID = B.USERID;


--3번 유저가 나오게.
SELECT *
FROM USERS U, BOARD B
WHERE U.ID = B.USERID;

SELECT *
FROM USERS U, REPLY R
WHERE U.ID = R.USERID(+)
AND R.ID IS NULL;


SELECT *
FROM USERS U, REPLY R
WHERE U.ID = R.USERID(+)
MINUS
SELECT *
FROM USERS U, REPLY R
WHERE U.ID = R.USERID;


--USER ID를 USER NAME으로 바꾸기
SELECT  B.ID, B.TITLE,B.USERID, COUNT(R.ID) "댓글수"
FROM BOARD B, REPLY R, USERS U
WHERE B.ID(+) = R.BOARDID(+) AND 
GROUP BY B.ID, B.TITLE, B.USERID;




--다 보여주고 싶은거 기준으로 RIGHT OUTTER 조인
SELECT ID, TITLE, USERID,
(SELECT COUNT(*) FROM REPLY WHERE BOARDID = B.ID) "댓글수"
FROM BOARD B;


SELECT ENAME, SAL + 20000
FROM EMP;

----------셀프조인할 때 드라이빙 테이블의 이해
SELECT E1.EMPNO, E1.ENAME, E1.JOB, E1.MGR, E2.ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO;


SELECT E1.EMPNO, E1.ENAME, E1.JOB, E1.MGR, E2.ENAME
FROM EMP E1, EMP E2
WHERE E2.EMPNO = E1.MGR ;



------View 뷰

SELECT *
FROM STUDENT;




SELECT E.EMPNO, E.ENAME, E.DEPTNO, D.DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;


--ANSI 문법 JOIN, ON(위에 오라클 문법하고 비교)

SELECT E.EMPNO, E.ENAME, E.DEPTNO, D.DNAME
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO AND E.DEPTNO= 10;    
--WHERE E.DEPTNO = 10; AND E.DEPTNO= 10; 대신 가능
--ANSI 표준에서 JOIN할때 WHERE 절 생략가능


SELECT *
FROM BOARD B, REPLY R
WHERE B.ID = R.BOARDID;


SELECT *
FROM BOARD B LEFT OUTER JOIN REPLY R
ON B.ID = R.BOARDID;

SELECT *
FROM BOARD B RIGHT OUTER JOIN REPLY R
ON B.ID = R.BOARDID;

--FULL OUTER JOIN

SELECT *
FROM BOARD B FULL OUTER JOIN REPLY R
ON B.ID = R.BOARD;





SELECT STUDNO, NAME, ID, GRADE, HEIGHT, WEIGHT, DEPTNO1, DEPTNO2, PROFNO
FROM STUDENT;



CREATE TABLE STUDENT2
AS
SELECT STUDNO, NAME, ID, GRADE, HEIGHT, WEIGHT, DEPTNO1, DEPTNO2, PROFNO
FROM STUDENT;


SELECT * FROM STUDENT2;



CREATE OR REPLACE VIEW STUDENT_VIEW 
AS
SELECT STUDNO, NAME, ID, GRADE, HEIGHT, WEIGHT, DEPTNO1, DEPTNO2, PROFNO
FROM STUDENT;



SELECT *
FROM STUDENT_VIEW;

INSERT INTO STUDENT_VIEW(STUDNO, NAME, ID, GRADE, HEIGHT, WEIGHT, DEPTNO1, DEPTNO2, PROFNO)
VALUES(4333, '이아무', 'SDWINI', 4, 150, 40, 111, NULL, NULL);



--296PAGE ~ 315PAGE 실습

SELECT *
FROM DEPT2;

--DEPT2라는 테이블에 행을 삽입한다
INSERT INTO DEPT2(DCODE, DNAME, PDEPT, AREA)
--모든컬럼을 데이터에 넣을 경우 테이블 이름뒤에 컬럼 이름 생략 가능
VALUES(9000, 'TEMP_1', 1006, 'TEMP AREA');

INSERT INTO DEPT2(DCODE, DNAME, PDEPT)
VALUES(9002, 'TEMP_3', 1006);




--날짜 유닉스와 윈도우 날짜형식 달라서 맞춰주는거 생각해야함
--맞추는 방법 ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD:HH24:MI:SS'

CREATE TABLE T_MINUS
(
NO1 NUMBER,
NO2 NUMBER(3),
NO3 NUMBER(3, 2)  --NUMBER(3, 2)  3자릿수에 소숫점2자릿수까지
);

INSERT INTO T_MINUS
VALUES(1, 1, 1);

INSERT INTO T_MINUS 
VALUES(1.1, 1.1, 1.1);

INSERT INTO T_MINUS 
VALUES(-1.1, -1.1, -1.1);


SELECT *
FROM T_MINUS;



---서브쿼리를 이용해서 가져오는 이방법을 ITAS라고 부름
CREATE TABLE PROFESSOR3
AS
SELECT *
FROM PROFESSOR
WHERE 1 = 2;

SELECT *
FROM PROFESSOR3;

INSERT INTO PROFESSOR3
SELECT *
FROM PROFESSOR;
-- PROFESSOR의 내용을 PROFESSOR3 안으로 넣기


CREATE TABLE PROFESSOR4
AS
SELECT PROFNO, NAME, PAY
FROM PROFESSOR
WHERE 1 = 2;  ---아무것도 안나오게 하기 위해서

INSERT INTO PROFESSOR4
SELECT PROFNO, NAME, PAY
FROM PROFESSOR
WHERE PROFNO > 4000;   --ITAS를 이용하고 WHERE로 조건에 맞는거 불러오는거

--INSERT ALL을 이용한 여러 테이블에 여러행 입력하기

CREATE TABLE PROF_3
(PROFNO NUMBER, NAME VARCHAR2(25));

CREATE TABLE PROF_4
(PROFNO NUMBER, NAME VARCHAR2(24));

--다른 테이블에 데이터를 가져와서 입력하기
INSERT ALL
WHEN PROFNO BETWEEN 1000 AND 1999 THEN
INTO PROF_3 VALUES(PROFNO, NAME)
WHEN PROFNO BETWEEN 2000 AND 2999 THEN
INTO PROF_4 VALUES(PROFNO, NAME)
SELECT PROFNO, NAME
FROM PROFESSOR;

SELECT *
FROM PROF_3;

SELECT *
FROM PROF_4;


--다른 테이블에 동시에 같은 데이터 입력하기
TRUNCATE TABLE PROF_3;
TRUNCATE TABLE PROF_4;

INSERT ALL
    INTO PROF_3 VALUES(PROFNO, NAME)
    INTO PROF_4 VALUES(PROFNO, NAME)
SELECT PROFNO, NAME
FROM PROFESSOR
WHERE PROFNO BETWEEN 3000 AND 3999;



--UPDATE (데이터 변경하기) : 기존 데이터를 다른 데이터로 변경할 때 사용

SELECT *
FROM PROFESSOR;

UPDATE PROFESSOR
SET BONUS = 200
WHERE POSITION = '조교수';

UPDATE PROFESSOR
SET PAY = PAY * 1.15
WHERE POSITION = ( SELECT POSITION
                   FROM PROFESSOR
                   WHERE NAME = '허은')
AND PAY < 250;



--DELETE 

DELETE FROM DEPT2
WHERE DCODE >= 9000 AND DCODE <= 9999;

--MERGE

CREATE TABLE CHARGE_01
(U_DATE VARCHAR(6),
CUST_NO NUMBER,
U_TIME NUMBER,
CHARGE NUMBER);


CREATE TABLE CHARGE_02
(U_DATE VARCHAR2(6),
CUST_NO NUMBER,
U_TIME NUMBER,
CHARGE NUMBER);


INSERT INTO CHARGE_01 VALUES ('141001', 1000,2 ,1000);
INSERT INTO CHARGE_01 VALUES ('141001', 1001,2 ,1000);
INSERT INTO CHARGE_01 VALUES ('141001', 1002,1 ,500);

INSERT INTO CHARGE_02 VALUES ('141002', 1000,3 ,1500);
INSERT INTO CHARGE_02 VALUES ('141002', 1001,4 ,2500);
INSERT INTO CHARGE_02 VALUES ('141002', 1003,1 ,500);
COMMIT;



CREATE TABLE CH_TOTAL
(U_DATE VARCHAR2(6),
CUST_NO NUMBER,
U_TIME NUMBER,
CHARGE NUMBER);

MERGE INTO CH_TOTAL TOTAL
USING CHARGE_01 CH01
ON(TOTAL.U_DATE = CH01.U_DATE)
WHEN MATCHED THEN
UPDATE SET TOTAL.CUST_NO = CH01.CUST_NO
WHEN NOT MATCHED THEN
INSERT VALUES(CH01.U_DATE, CH01.CUST_NO, CH01.U_TIME, CH01.CHARGE);


MERGE INTO CH_TOTAL TOTAL
USING CHARGE_02 CH02
ON(TOTAL.U_DATE = CH02.U_DATE)
WHEN MATCHED THEN
    UPDATE SET TOTAL.CUST_NO = CH02.CUST_NO
WHEN NOT MATCHED THEN
INSERT VALUES(CH02.U_DATE, CH02.CUST_NO, CH02.U_TIME, CH02.CHARGE);

SELECT * 
FROM CH_TOTAL;



--UPDATE 조인

--일반적인 UPDATE : 단일 테이블
--직업이 "CLERK"인 사원의 급여를 100%인상합니다

UPDATE EMP
SET SAL = (SAL + SAL*0.1)
WHERE JOB = 'CLERK';


--일반적인 UPDATE조인 : WHERE 절에서 다른 테이블과 조인
--부서가 DALLAS 에 위치하는 부서에서 근무하는 사원의 급여를 100% 인상합니다.

UPDATE EMP E
SET SAL = (SAL + SAL*0.1)
WHERE EXISTS
(
SELECT 1 FROM DEPT D
WHERE D.LOC = 'DALLAS' AND
      E.DEPTNO = D.DEPTNO
);
  
  
SELECT 1 
FROM DEPT;    


CREATE TABLE DEP_HIST --부서발령이력
(
    EMPNO NUMBER(4),        --사원번호 PK1
    APPOINTSEQNO NUMBER(4), --발령순번 PK2
    DEPTNO NUMBER(2),       --부서번호
    APPOINTDD DATE          --발령일자
);


--테스트 데이터로 부서번호가 20인 사원 발령 부서번호 99로 테이터를 INSERT
INSERT INTO DEP_HIST
SELECT EMPNO, 1 APPOINTSEQNO, 99 DEPTNO, SYSDATE APPOINTDD 
FROM EMP
WHERE DEPTNO = 20;
COMMIT;



--EMP 테이블에 존재하지 않는 사원번호 2건을 INSERT
INSERT INTO DEP_HIST VALUES (9322 ,1, 99, SYSDATE);
INSERT INTO DEP_HIST VALUES (9414, 1, 99, SYSDATE);

COMMIT;


SELECT *
FROM DEP_HIST;





SELECT SAL 
FROM EMP 
WHERE ENAME = 'SMITH';


SELECT *
FROM EMP
WHERE SAL > (SELECT SAL 
FROM EMP 
WHERE ENAME = 'SMITH');


--이거 다시확인
SELECT *
FROM EMP
WHERE SAL IN (SELECT SAL             --IN OR 하고 똑같음
FROM EMP 
WHERE JOB = 'MANAGER');

SELECT *
FROM EMP
WHERE SAL = 3599 OR SAL = 2850 OR SAL = 2450;

SELECT *
FROM EMP
WHERE SAL IN(3599, 2850, 2450);


SELECT ENAME, COMM
FROM EMP
WHERE COMM < (SELECT COMM
              FROM EMP
              WHERE ENAME = 'WARD');
              
              
              
              
              
SELECT DEPTNO1, NAME
FROM STUDENT;

SELECT *
FROM STUDENT;

SELECT *
FROM DEPARTMENT;

SELECT *
FROM
(
SELECT *
FROM STUDENT
WHERE NAME = '서진수'
)
WHERE DEPTNO =;

SELECT *
FROM
(SELECT 
FROM STUDENT
WHERE NAME= '서진수')
WHERE DEPTNO1= '10';

SELECT *
FROM DEPARTMENT;

SELECT *
FROM STUDENT;




SELECT DNAME, NAME
FROM DEPARTMENT, STUDENT
WHERE 
(
SELECT DEPTNO1
FROM STUDENT
WHERE NAME = '서진수')= DEPTNO;




SELECT NAME
FROM STUDENT
WHERE DEPTNO =
(SELECT DEPTNO1
FROM STUDENT
WHERE NAME = '서진수');




SELECT *
FROM STUDENT;


S

SELECT DEPTNO1
FROM DEPARTMENT
WHERE DEPTNO1 =;




SELECT *
FROM DEPARTMENT;

SELECT *
FROM STUDENT;

SELECT NAME
FROM STUDNET
WHERE DEPTNO1 =
(SELECT DEPTNO
FROM DEPARTMENT;

SELECT NAME
FROM STUDENT,
WHERE DEPTNO1 =(SELECT DEPTNO1
FROM STUDENT
WHERE NAME = '서진수');

SELECT *
FROM DEPARTMENT;
----------------------다시 풀기 계풀기
SELECT NAME, DNAME
FROM STUDENT, DEPARTMENT
WHERE DEPTNO1 =(SELECT DEPTNO1
FROM STUDENT
WHERE NAME = '서진수'); AND DNAME ='컴퓨터공학과';




SELECT NAME                             ---여기서 테이블합치는법
FROM STUDENT
WHERE DEPTNO1 =(SELECT DEPTNO1
FROM STUDENT
WHERE NAME = '서진수');






SELECT NAME, DNAME                            ---여기서 테이블합치는법
FROM STUDENT, DEPARTMENT
WHERE DEPTNO1
=(SELECT DEPTNO1 FROM STUDENT WHERE NAME = '서진수')
 AND DEPTNO1=DEPTNO;















SELECT *
FROM STUDENT;

SELECT *
FROM DEPARTMENT;


SELECT S.NAME, D.DNAME
FROM STUDENT S, DEPARTMENT D
WHERE
S.DEPTNO1 =(SELECT DEPTNO1
          FROM STUDENT 
          WHERE NAME='서진수') 
AND DEPTNO1 = DEPTNO;




SELECT *
FROM PROFESSOR;

SELECT *
FROM DEPARTMENT;

SELECT HIREDATE
FROM PROFESSOR
WHERE NAME = '조인형';
    
    
SELECT NAME
FROM PROFESSOR
WHERE HIREDATE >
(SELECT HIREDATE FROM PROFESSOR WHERE NAME ='조인형');
    
    
SELECT P.NAME, P.HIREDATE, D.DNAME DEPT_NAME 
FROM PROFESSOR P, DEPARTMENT D
WHERE HIREDATE  > (SELECT HIREDATE
FROM PROFESSOR
WHERE NAME = '조인형')
AND P.DEPTNO = D.DEPTNO
;



SELECT NAME
FROM PROFESSOR

WHERE HIREDATE > (SELECT HIREDATE
FROM PROFESSOR
WHERE NAME = '조인형');


SELECT *
FROM REPLY;

SELECT ID, TITLE, (SELECT COUNT(*) FROM REPLY WHERE ID = B.ID)
FROM BOARD B;
--LEFTER OUTTER JOIN을 쓸것

SELECT *
FROM BOARD;

SELECT *
FROM REPLY;


SELECT ID, TITLE
FROM BOARD;

